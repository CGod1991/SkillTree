# JVM 内存管理和垃圾回收

标签：JVM 垃圾回收

## 运行时数据区

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存区域划分为若干个不同的数据区域，按照其生命
周期可分为两种类型：线程私有和线程共享。其中属于线程私有的数据区域为程序计数器、虚拟机栈和本地
方法栈，属于线程共享的为堆和方法区。

### 程序计数器

是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过
改变程序计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都需要依赖程序
计数器来完成。

### 虚拟机栈

虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变
量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就是一个栈帧在虚拟机
栈中入栈到出栈的过程。

在虚拟机栈中有两种异常情况：
- 如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出 StackOverflowError 异常。
- 如果虚拟机栈可以扩展，在扩展时无法申请到足够的内存，则会抛出 OutOfMemoryError 异常。

### 本地方法栈

本地方法栈发挥的作用和虚拟机栈几乎一样，唯一的区别就是虚拟机栈是为虚拟机执行 Java 方法服务的，
而本地方法栈则是为虚拟机使用到的 Native 方法服务的。

### 堆

Java 堆是被所有线程共享的内存区域，在虚拟机启动时创建。Java 堆的唯一目的就是存放 Java 对象实例，
几乎所有的对象实例是在堆中分配的。

Java 堆是垃圾收集器管理的主要内存区域，还可以进一步细分为新生代和老年代，其中新生代还可以被分为
Eden 空间、From Survivor空间、To Survivor空间等。

如果在堆中没有足够的内存空间分配实例，并且堆也无法扩展时，会抛出 OutOfMemoryError 异常。

### 方法区

主要用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

在 HotSpot 虚拟机中，通常将方法区也称为“永久代”。

## HotSpot 虚拟机

### 对象的创建

对象所需要的内存空间，在类加载完成后便可以完全确定，为对象分配空间实际上就是把一块确定大小的内存
从 Java 堆中划分出来。

在对象头中包含了虚拟机对该对象的一些必要设置，主要包括该对象是哪个类的实例、如何才能找到类的元数
据信息、对象的哈希码、对象的 GC 分代年龄等信息。

### 对象的内存布局

对象在内存中存储的布局可以分为三个区域：对象头、实例数据和对齐填充。

#### 对象头

HotSpot 虚拟机的对象头主要包括两部分的信息：
- 第一部分存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、
偏向时间戳等。
- 另一部分存储类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。

#### 实例数据

存储了对象真正的有效数据，也就是在程序代码中所定义的各种类型的字段内容。

#### 对齐填充

并不要求必须存在，仅仅起着占位符的作用。

### 对象的访问

Java 程序是通过栈上的引用数据来操作堆上的具体对象。

目前主要的对象访问方式有两种：使用句柄或直接指针。
- 使用句柄：Java 堆中会划分出一块内存来作为句柄池，引用数据中存储的就是对象的句柄地址，而句柄中
包含了对象实例数据和类型数据的具体地址信息。
- 使用直接指针：引用数据中存储的直接就是对象的地址。

使用句柄的优势是引用数据中存储的是稳定的句柄地址，在对象被移动时，只会修改句柄中的实例数据的指针，
而引用数据本身不会被修改;使用直接指针的优点是速度快，因为节省了一次指针定位的时间开销。

HotSpot 虚拟机使用的是直接指针的方式来进行对象访问。

## 内存分配

