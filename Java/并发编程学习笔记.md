# 并发编程学习笔记

标签：并发

---

## 简介

- 对于并发编程而言，多线程是基础。
- 线程模型是一种程序编写规范，可在单独一个程序里实现几个操作的同时进行。
- 在任何时刻，只能有一个线程调用特定对象的一个synchronized方法，而一个特定对象的所有synchronized方法都共享一把锁，这样就能防止多个方法对通用内存同时进行操作。
- 对于访问某个关键共享资源的所有方法，都必须把它们设为synchronized方法。
- 线程是进程中一个任务控制流序列，在多个线程之间可以共享进程数据，比如内存句柄和文件句柄，但每个线程都有自己的程序计数器、栈以及局部变量等。
- 在同一个进程中，可以存在多个任务控制流。
- 通过使用线程，可以将负责且异步的工作流进一步分解为一组简单且同步的工作流，每个工作流在一个单独的线程中执行，并在特定的同步位置进行交互。
- 要使多线程程序的行为可以预测，必须对共享变量的操作进行协同，这样才不会在线程之间进行干扰。
- 安全性的含义是“永远不要发生糟糕的事情”，而活跃性则关注“某件正确的事最终一定会发生”。
- 程序的性能问题主要关注以下几个方面：
	- 服务时间过程。
	- 响应不灵敏。
	- 吞吐率过低。
	- 资源消耗过高。
	- 可伸缩性较低。

- 

### 线程的四种状态

1. New：线程对象已创建，但是尚未启动，所以不可运行。即调用start()方法之前。
2. Runnable：此时线程对象已经调用了start()方法，但并不意味着此时线程一定在运行当中，因为需要时间分片机制此时能够提供空闲的CPU周期。所以此时线程的状态是：可能在、也可能不在运行状态，但只要条件一允许，就没有什么能阻止线程运行。此时线程既没有死掉，也没有被阻塞。
3. Dead：从自己的run()方法返回。也可以显式的调用stop()方法杀掉线程，但是会产生一个Error，通常并不建议如此做。
4. Blocked：线程可以运行，但是有某种东西阻碍了线程的运行，即此时线程不在运行中。对于调度机制来说，如果一个线程处于阻塞状态，则此时可以直接跳过该线程而不给其分配任何CPU时间，除非该线程进入Runnable状态，否则不对其采取任何操作。造成线程阻塞的原因主要有以下几种：
	- 调用sleep()，使线程进入睡眠状态。
	- 用suspend()暂停线程的执行，除非线程收到resume()命令，否则不会进入Runnable状态。
	- 使用wait()暂停线程的执行，除非线程收到notify()或者notifyAll()消息，否则不会进入Runnable状态。
	- 线程正在等待IO操作完成。
	- 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。