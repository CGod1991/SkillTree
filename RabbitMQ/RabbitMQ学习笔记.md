# RabbitMQ 学习笔记

标签：RabbitMQ

---

## 概述

- 消息队列（message queuing）提供一个异步通信协议，消息的发送者不用一直等待消息被成功处理，而是立即返回。消息被暂存于队列中，对消息感兴趣的消费者会订阅并处理它们。
- 消息通信从本质上来说是异步的，因为它通过分隔数据的发送和接收来解耦应用。
- 消息队列使用消息将应用程序连接起来，这些消息通过像 RabbitMQ 这样的消息代理服务器在应用程序之间进行路由。

## 消息通信

- 一条消息主要包含两部分：
	- 有效载荷（payload）：想要传输的数据。可以是任何内容。
	- 标签（label）：用于描述有效载荷。RabbitMQ 通过标签来决定谁将获得消息的拷贝。


- 当消费者接收到消息时，实际上只接收到了部分消息，即只收到了有效载荷，在消息路由的过程中，消息的标签并没有随有效载荷一起进行传递。甚至 RabbitMQ 都不会告诉消费者生产者是谁。
- 无论是作为生产者还是消费者，想要通过 RabbitMQ 生产或消费消息，必须要跟 RabbitMQ 连接上。信道（channel）就是生产者或消费者跟 RabbitMQ 之间的连接，实际上是 TCP 连接中的一条虚拟连接，而该 TCP 连接是应用程序和 RabbitMQ 之间的连接。在 TCP 连接中可以创建多条信道，每条信道都会分配一个唯一的信道 ID，后续的所有动作，包括发布消息、订阅队列和接收消息等，都是通过信道完成的。
- 消费者和生产者是消息发送和接收概念的体现，而不是客户端和服务器端。
- 从概念上将，AMQP（Advanced Message Queuing Protocol，高级消息队列协议）必须有三部分：交换器、队列和绑定。
- 生产者把消息发送到交换器；消息最终到达队列，并被消费者接收；绑定决定了消息如何从路由器到达特定的队列。
- 消费者主要通过两种方式从特定的队列中接收消息：
	- 通过 AMQP 的 basic.consume 命令订阅。如果消费者处理队列消息，需要在消息一到达队列就自动接收，那么应该使用该方式订阅消息。
	- 通过 AMQP 的 basic.get 命令。该命令只是从队列中获取单条消息而不是持续订阅。


- 当一个队列有多个消费者时，队列以轮询的方式将消息发送给消费者。同时，每条消息只会发送给一个消费者。
- 消费者接收到的每条消息都必须进行确认，必须通过 AMQP 的 basic.ack 命令显示的向 RabbitMQ 发送一个确认，或者在订阅到队列的时候就将 auto_ack 设置为 true。
- 如果消费者没有对上一条消息进行确认的话，当新的消息到来时，RabbitMQ 将不会给该消费者发送任何消息，直到上一条消息被确认。因为 RabbitMQ 会认为该消费者没有为接收新的消息做好准备。
- 消费者在订阅队列时需要指定队列名称，在创建绑定时也需要指定队列名称。
- 路由键（routing key）：确定的规则，RabbitMQ 根据该规则来决定将消息发送到哪个队列。
- RabbitMQ 中主要有以下几种类型的交换器：
	- direct：如果路由键匹配的话，消息就会被路由到对应的队列。
	- fanout：当发送一条消息到 fanout 交换器时，它会将该消息路由给所有附加在该交换器上的队列。
	- topic：使来自不同源头的消息能够到达同一个队列。


- 在 RabbitMQ 中，每一个 vhost（虚拟主机）都是一个简化版的 RabbitMQ 服务器，拥有自己的交换器、队列和绑定。更重要的是，它拥有自己的权限，不同的 vhost 之间是隔离的。
- 默认情况下，重启 RabbitMQ 服务器后，队列和交换器都会消失，包括其中的消息。
- 如果想要消息持久化，需要做到以下几点：
	- 将消息的投递模式设置为 2（持久）；
	- 将消息发送到持久化的交换器；
	- 消息必须到达持久化的队列。


- RabbitMQ 确保持久性消息能够在 RabbitMQ 服务器重启中恢复的方式是，将消息写入磁盘中的一个持久化日志文件中。
- 如果持久化队列中的某条消息被消费了，那么 RabbitMQ 会在持久化日志中将该条消息标记为等待垃圾收集。
- 对于生产者来说，需要完成以下几个操作：
	- 连接到 RabbitMQ
	- 获取信道
	- 声明交换器
	- 创建消息
	- 发布消息
	- 关闭信道
	- 关闭连接


- 对于消费者来说，需要完成以下几个操作：
	- 连接到 RabbitMQ
	- 获得信道
	- 声明交换器
	- 声明队列
	- 把队列和交换器绑定起来
	- 消费消息
	- 关闭信道
	- 关闭连接


- declare 命令的语义是“如果没有就创建，否则什么也不做”。

## 管理 RabbitMQ

- 在这里，节点指的是一个 Erlang 节点并运行着一个 Erlang 程序。当提到 RabbitMQ 节点时，实际上指的是 RabbitMQ 应用程序和其所在的 Erlang 节点。
- 多个 Erlang 应用程序可以运行在一个节点上，同时，节点之间可以进行本地通信，不管它们是否真的在同一台服务器上。
- 常用的 rabbitmqctl 命令：
	- stop：和本地节点通信并指示其干净的关闭。可以使用 `-n rabbit@hostname` 参数，关闭指定的远程节点。
	- stop_app：只停止 RabbitMQ 应用，而不关闭节点。


- rabbitmq-server 命令同时启动了节点和应用程序，它把 RabbitMQ 应用预先设置成了独立运行模式。如果想把节点加入到现有集群中，需要先停止节点上的应用程序，然后把节点重置为原始状态。
- RabbitMQ 中的每个队列、交换器和绑定的元数据（除了内容）都是保存到 Mnesia 的。Mnesia 是内建在 Erlang 中的非 SQL 型数据库。
- 在 RabbitMQ 中，用户是访问控制的基本单元。
- RabbitMQ 权限系统中，用户的读、写和配置权限：
	- 读：有关消费消息的任何操作，包括“清除”整个队列（需要绑定操作的成功）。
	- 写：发布消息（需要绑定操作的成功）。
	- 配置：队列和交换器的创建和删除。

## 集群

- RabbitMQ 内建集群主要用于完成两个设计目标：
	- 允许消费者和生产者在节点崩溃的情况下继续运行。
	- 通过添加更多的节点来线性扩展消息通信吞吐量。


- 当一个节点崩溃时，该节点上队列的消息也会消失，因为 RabbitMQ 默认不会将队列的内容复制到整个集群。
- RabbitMQ 会始终记录以下四种类型的内部元数据：
	- 队列元数据：队列名称和它们的属性（是否可持久化，是否自动删除）。
	- 交换器元数据：交换器名称、类型和属性。
	- 绑定元数据：一张简单的表格展示了如何将消息路由到队列。
	- vhost 元数据：为 vhost 内部的队列、交换器和绑定提供命名空间和安全属性。


- 交换器本质上只是一个名称和一个队列绑定列表，当消息被发布到交换器时，实际上是所连接的信道将消息上的路由键和交换器中的绑定列表做比较，然后路由消息。
- 由于交换器只是一张查询表，并不是真正的消息路由器（实际上的消息路由器是信道），因此可以将交换器在集群中进行复制而不会消耗太多的资源，也更简单。
- 对于 RabbitMQ 节点来说，要么是内存节点，要么是磁盘节点，不论是在单节点系统中还是集群中。
	- 内存节点：所有队列、交换器、绑定、用户、权限和 vhost 的元数据定义都只是存储在内存中。
	- 磁盘节点：所有的元数据信息存储在磁盘中。对于单节点系统，只允许节点为磁盘节点。


- 内存节点唯一存储到磁盘的元数据信息是集群中磁盘节点的地址。
- 当在集群中生命交换器、队列和绑定时，这些操作会等到集群中所有节点都成功提交元数据后才返回。
- 在 RabbitMQ 集群中，要求至少有一个磁盘节点，当有节点加入或离开时，需要将该变更通知到至少一个磁盘节点。
- 构建 RabbitMQ 集群来确保可用性和性能只是保障弹性消息通信基础架构的一半，另一半是编写当节点发生故障时知道如何重连到集群的应用程序。
- 一台负载均衡器表示了单个 IP 地址背后存在多台服务器。
- 当为 RabbitMQ 集群添加了负载均衡器，集群中的节点就相当于负载均衡器背后的服务器，而生产者和消费者则是客户。